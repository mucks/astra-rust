/* automatically generated by rust-bindgen */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 30;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ASTRA_TRUE: u32 = 1;
pub const ASTRA_FALSE: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const ASTRA_MAX_JOINTS: u32 = 19;
pub const ASTRA_INVALID_BODY_ID: u32 = 0;
pub const ASTRA_MIN_BODY_ID: u32 = 1;
pub const ASTRA_MAX_BODY_ID: u32 = 255;
pub const ASTRA_MAX_BODIES: u32 = 6;
pub const ASTRA_TEMP_IMAGE_WIDTH: u32 = 640;
pub const ASTRA_TEMP_IMAGE_HEIGHT: u32 = 480;
pub const ASTRA_TEMP_IMAGE_LENGTH: u32 = 307200;
pub const ASTRA_SERIAL_NUMBER_MAX: u32 = 256;
pub const ASTRA_HANDS_MAX_HAND_COUNT: u32 = 10;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub const ASTRA_STREAMSET_URI_MAX_LENGTH: u32 = 256;
pub const ASTRA_MAX_READER_STREAMS: u8 = 16;
pub const ASTRA_TIMEOUT_FOREVER: ::std::os::raw::c_int = -1;
pub const ASTRA_TIMEOUT_RETURN_IMMEDIATELY: ::std::os::raw::c_int = 0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _astra_stream {
    _unused: [u8; 0],
}
pub type astra_stream_t = *mut _astra_stream;
pub type astra_stream_type_t = i32;
pub type astra_stream_subtype_t = i32;
pub type astra_frame_index_t = i32;
pub const DEFAULT_SUBTYPE: astra_stream_subtype_t = 0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct astra_stream_desc_t {
    pub type_: astra_stream_type_t,
    pub subtype: astra_stream_subtype_t,
}
#[test]
fn bindgen_test_layout_astra_stream_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<astra_stream_desc_t>(),
        8usize,
        concat!("Size of: ", stringify!(astra_stream_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<astra_stream_desc_t>(),
        4usize,
        concat!("Alignment of ", stringify!(astra_stream_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_stream_desc_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_stream_desc_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_stream_desc_t>())).subtype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_stream_desc_t),
            "::",
            stringify!(subtype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct astra_version_info_t {
    pub majorVersion: i32,
    pub minorVersion: i32,
    pub patchVersion: i32,
    pub versionSuffix: *mut ::std::os::raw::c_char,
    pub gitCommitSha1: *mut ::std::os::raw::c_char,
    pub friendlyVersionString: *mut ::std::os::raw::c_char,
    pub apiLevel: i32,
}
#[test]
fn bindgen_test_layout_astra_version_info_t() {
    assert_eq!(
        ::std::mem::size_of::<astra_version_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(astra_version_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<astra_version_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(astra_version_info_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_version_info_t>())).majorVersion as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_version_info_t),
            "::",
            stringify!(majorVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_version_info_t>())).minorVersion as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_version_info_t),
            "::",
            stringify!(minorVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_version_info_t>())).patchVersion as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_version_info_t),
            "::",
            stringify!(patchVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_version_info_t>())).versionSuffix as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_version_info_t),
            "::",
            stringify!(versionSuffix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_version_info_t>())).gitCommitSha1 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_version_info_t),
            "::",
            stringify!(gitCommitSha1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_version_info_t>())).friendlyVersionString as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_version_info_t),
            "::",
            stringify!(friendlyVersionString)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_version_info_t>())).apiLevel as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_version_info_t),
            "::",
            stringify!(apiLevel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _astra_streamset {
    _unused: [u8; 0],
}
pub type astra_streamset_t = *mut _astra_streamset;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _astra_streamconnection_handle {
    _unused: [u8; 0],
}
pub type astra_streamconnection_handle_t = *mut _astra_streamconnection_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _astra_streamsetconnection {
    pub _unused: [u8; 0],
}
pub type astra_streamsetconnection_t = *mut _astra_streamsetconnection;
#[repr(C)]
#[derive(Debug, Copy, Clone, Default)]
pub struct _astra_streamconnection {
    _unused: [u8; 0],
}
pub type astra_streamconnection_t = *mut _astra_streamconnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _astra_frame {
    _unused: [u8; 0],
}
pub type astra_frame_t = _astra_frame;
#[repr(C)]
#[derive(Debug, Copy, Clone, Default)]
pub struct _astra_reader {
    _unused: [u8; 0],
}
pub type astra_reader_t = *mut _astra_reader;
#[repr(C)]
#[derive(Debug, Copy, Clone, Default)]
pub struct _astra_reader_frame {
    _unused: [u8; 0],
}
pub type astra_reader_frame_t = *mut _astra_reader_frame;
pub type astra_parameter_data_t = *mut ::std::os::raw::c_void;
pub type astra_parameter_id = i32;
pub type astra_command_id = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _astra_parameter_bin {
    _unused: [u8; 0],
}
pub type astra_result_token_t = *mut _astra_parameter_bin;
pub type astra_parameter_bin_t = *mut _astra_parameter_bin;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _astra_bin {
    _unused: [u8; 0],
}
pub type astra_bin_t = *mut _astra_bin;
pub const astra_status_t_ASTRA_STATUS_SUCCESS: astra_status_t = 0;
pub const astra_status_t_ASTRA_STATUS_INVALID_PARAMETER: astra_status_t = 1;
pub const astra_status_t_ASTRA_STATUS_DEVICE_ERROR: astra_status_t = 2;
pub const astra_status_t_ASTRA_STATUS_TIMEOUT: astra_status_t = 3;
pub const astra_status_t_ASTRA_STATUS_INVALID_PARAMETER_TOKEN: astra_status_t = 4;
pub const astra_status_t_ASTRA_STATUS_INVALID_OPERATION: astra_status_t = 5;
pub const astra_status_t_ASTRA_STATUS_INTERNAL_ERROR: astra_status_t = 6;
pub const astra_status_t_ASTRA_STATUS_UNINITIALIZED: astra_status_t = 7;
pub type astra_status_t = u32;
pub type astra_callback_id_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _astra_reader_callback_id {
    _unused: [u8; 0],
}
pub type astra_reader_callback_id_t = *mut _astra_reader_callback_id;
pub type astra_frame_ready_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientTag: *mut ::std::os::raw::c_void,
        reader: astra_reader_t,
        frame: astra_reader_frame_t,
    ),
>;
pub const astra_log_severity_t_ASTRA_SEVERITY_UNKNOWN: astra_log_severity_t = 0;
pub const astra_log_severity_t_ASTRA_SEVERITY_FATAL: astra_log_severity_t = 1;
pub const astra_log_severity_t_ASTRA_SEVERITY_ERROR: astra_log_severity_t = 2;
pub const astra_log_severity_t_ASTRA_SEVERITY_WARN: astra_log_severity_t = 3;
pub const astra_log_severity_t_ASTRA_SEVERITY_INFO: astra_log_severity_t = 4;
pub const astra_log_severity_t_ASTRA_SEVERITY_DEBUG: astra_log_severity_t = 5;
pub const astra_log_severity_t_ASTRA_SEVERITY_TRACE: astra_log_severity_t = 6;
pub type astra_log_severity_t = u32;
pub const astra_chip_id_t_ASTRA_CHIP_ID_UNKNOWN: astra_chip_id_t = 0;
pub const astra_chip_id_t_ASTRA_CHIP_ID_MX400: astra_chip_id_t = 1;
pub const astra_chip_id_t_ASTRA_CHIP_ID_MX6000: astra_chip_id_t = 2;
pub const astra_chip_id_t_ASTRA_CHIP_ID_DUAL_MX6000: astra_chip_id_t = 3;
pub type astra_chip_id_t = u32;
pub type astra_event_id = u32;
pub type astra_bool_t = i8;
extern "C" {
    pub fn astra_core_version(info: *mut astra_version_info_t) -> astra_status_t;
}
extern "C" {
    pub fn astra_initialize() -> astra_status_t;
}
extern "C" {
    pub fn astra_terminate() -> astra_status_t;
}
extern "C" {
    pub fn astra_notify_plugin_event(
        id: astra_event_id,
        data: *const ::std::os::raw::c_void,
        dataSize: u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_streamset_is_available(
        connection: astra_streamsetconnection_t,
        isAvailable: *mut bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_streamset_open(
        connectionString: *const ::std::os::raw::c_char,
        streamSet: *mut astra_streamsetconnection_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_streamset_close(streamSet: *mut astra_streamsetconnection_t) -> astra_status_t;
}
extern "C" {
    pub fn astra_streamset_get_uri(
        connection: astra_streamsetconnection_t,
        uri: *mut ::std::os::raw::c_char,
        size: i32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_reader_create(
        streamSet: astra_streamsetconnection_t,
        reader: *mut astra_reader_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_reader_destroy(reader: *mut astra_reader_t) -> astra_status_t;
}
extern "C" {
    pub fn astra_reader_get_stream(
        reader: astra_reader_t,
        type_: astra_stream_type_t,
        subtype: astra_stream_subtype_t,
        connection: *mut astra_streamconnection_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_stream_get_description(
        connection: astra_streamconnection_t,
        description: *mut astra_stream_desc_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_stream_is_available(
        connection: astra_streamconnection_t,
        isAvailable: *mut bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_stream_start(connection: astra_streamconnection_t) -> astra_status_t;
}
extern "C" {
    pub fn astra_stream_stop(connection: astra_streamconnection_t) -> astra_status_t;
}
extern "C" {
    pub fn astra_reader_has_new_frame(
        reader: astra_reader_t,
        hasNewFrame: *mut bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_reader_open_frame(
        reader: astra_reader_t,
        timeoutMillis: ::std::os::raw::c_int,
        frame: *mut astra_reader_frame_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_reader_close_frame(frame: *mut astra_reader_frame_t) -> astra_status_t;
}
extern "C" {
    pub fn astra_reader_register_frame_ready_callback(
        reader: astra_reader_t,
        callback: astra_frame_ready_callback_t,
        clientTag: *mut ::std::os::raw::c_void,
        callbackId: *mut astra_reader_callback_id_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_reader_unregister_frame_ready_callback(
        callbackId: *mut astra_reader_callback_id_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_reader_get_frame(
        frame: astra_reader_frame_t,
        type_: astra_stream_type_t,
        subtype: astra_stream_subtype_t,
        subFrame: *mut *mut astra_frame_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_stream_set_parameter(
        connection: astra_streamconnection_t,
        parameterId: astra_parameter_id,
        inByteLength: u32,
        inData: astra_parameter_data_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_stream_get_parameter(
        connection: astra_streamconnection_t,
        parameterId: astra_parameter_id,
        resultByteLength: *mut u32,
        token: *mut astra_result_token_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_stream_get_result(
        connection: astra_streamconnection_t,
        token: astra_result_token_t,
        dataByteLength: u32,
        dataDestination: astra_parameter_data_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_stream_invoke(
        connection: astra_streamconnection_t,
        commandId: astra_command_id,
        inByteLength: u32,
        inData: astra_parameter_data_t,
        resultByteLength: *mut u32,
        token: *mut astra_result_token_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_update() -> astra_status_t;
}
extern "C" {
    pub fn astra_plugin_command(
        plugin_name: *const ::std::os::raw::c_char,
        command: *const ::std::os::raw::c_char,
        result: *mut ::std::os::raw::c_char,
        lengh: ::std::os::raw::c_int,
    ) -> astra_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct astra_vector2i_t {
    pub x: i32,
    pub y: i32,
}
#[test]
fn bindgen_test_layout_astra_vector2i_t() {
    assert_eq!(
        ::std::mem::size_of::<astra_vector2i_t>(),
        8usize,
        concat!("Size of: ", stringify!(astra_vector2i_t))
    );
    assert_eq!(
        ::std::mem::align_of::<astra_vector2i_t>(),
        4usize,
        concat!("Alignment of ", stringify!(astra_vector2i_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_vector2i_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_vector2i_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_vector2i_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_vector2i_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Default)]
pub struct astra_vector2f_t {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_astra_vector2f_t() {
    assert_eq!(
        ::std::mem::size_of::<astra_vector2f_t>(),
        8usize,
        concat!("Size of: ", stringify!(astra_vector2f_t))
    );
    assert_eq!(
        ::std::mem::align_of::<astra_vector2f_t>(),
        4usize,
        concat!("Alignment of ", stringify!(astra_vector2f_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_vector2f_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_vector2f_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_vector2f_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_vector2f_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Default)]
pub struct astra_vector3f_t {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_astra_vector3f_t() {
    assert_eq!(
        ::std::mem::size_of::<astra_vector3f_t>(),
        12usize,
        concat!("Size of: ", stringify!(astra_vector3f_t))
    );
    assert_eq!(
        ::std::mem::align_of::<astra_vector3f_t>(),
        4usize,
        concat!("Alignment of ", stringify!(astra_vector3f_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_vector3f_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_vector3f_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_vector3f_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_vector3f_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_vector3f_t>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_vector3f_t),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct astra_vector3i_t {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
#[test]
fn bindgen_test_layout_astra_vector3i_t() {
    assert_eq!(
        ::std::mem::size_of::<astra_vector3i_t>(),
        12usize,
        concat!("Size of: ", stringify!(astra_vector3i_t))
    );
    assert_eq!(
        ::std::mem::align_of::<astra_vector3i_t>(),
        4usize,
        concat!("Alignment of ", stringify!(astra_vector3i_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_vector3i_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_vector3i_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_vector3i_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_vector3i_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_vector3i_t>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_vector3i_t),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct astra_usb_info_t {
    pub pid: i32,
    pub vid: i32,
}
#[test]
fn bindgen_test_layout_astra_usb_info_t() {
    assert_eq!(
        ::std::mem::size_of::<astra_usb_info_t>(),
        8usize,
        concat!("Size of: ", stringify!(astra_usb_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<astra_usb_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(astra_usb_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_usb_info_t>())).pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_usb_info_t),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_usb_info_t>())).vid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_usb_info_t),
            "::",
            stringify!(vid)
        )
    );
}
#[doc = " \\brief Represents a 3x3 rotation matrix"]
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct _astra_matrix3x3 {
    pub __bindgen_anon_1: _astra_matrix3x3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _astra_matrix3x3__bindgen_ty_1 {
    pub __bindgen_anon_1: _astra_matrix3x3__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _astra_matrix3x3__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 9usize],
}

impl Default for _astra_matrix3x3__bindgen_ty_1 {
    fn default() -> Self {
        _astra_matrix3x3__bindgen_ty_1 {
            __bindgen_anon_1: _astra_matrix3x3__bindgen_ty_1__bindgen_ty_1::default(),
        }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone, Default)]
pub struct _astra_matrix3x3__bindgen_ty_1__bindgen_ty_1 {
    pub xAxis: astra_vector3f_t,
    pub yAxis: astra_vector3f_t,
    pub zAxis: astra_vector3f_t,
}
#[test]
fn bindgen_test_layout__astra_matrix3x3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_astra_matrix3x3__bindgen_ty_1__bindgen_ty_1>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(_astra_matrix3x3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_astra_matrix3x3__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_astra_matrix3x3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_astra_matrix3x3__bindgen_ty_1__bindgen_ty_1>())).xAxis
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_matrix3x3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(xAxis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_astra_matrix3x3__bindgen_ty_1__bindgen_ty_1>())).yAxis
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_matrix3x3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(yAxis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_astra_matrix3x3__bindgen_ty_1__bindgen_ty_1>())).zAxis
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_matrix3x3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(zAxis)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Default)]
pub struct _astra_matrix3x3__bindgen_ty_1__bindgen_ty_2 {
    pub m00: f32,
    pub m10: f32,
    pub m20: f32,
    pub m01: f32,
    pub m11: f32,
    pub m21: f32,
    pub m02: f32,
    pub m12: f32,
    pub m22: f32,
}
#[test]
fn bindgen_test_layout__astra_matrix3x3__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2>())).m00 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(m00)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2>())).m10 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(m10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2>())).m20 as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(m20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2>())).m01 as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(m01)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2>())).m11 as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(m11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2>())).m21 as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(m21)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2>())).m02 as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(m02)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2>())).m12 as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(m12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2>())).m22 as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_matrix3x3__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(m22)
        )
    );
}
#[test]
fn bindgen_test_layout__astra_matrix3x3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_astra_matrix3x3__bindgen_ty_1>(),
        36usize,
        concat!("Size of: ", stringify!(_astra_matrix3x3__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_astra_matrix3x3__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_astra_matrix3x3__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout__astra_matrix3x3() {
    assert_eq!(
        ::std::mem::size_of::<_astra_matrix3x3>(),
        36usize,
        concat!("Size of: ", stringify!(_astra_matrix3x3))
    );
    assert_eq!(
        ::std::mem::align_of::<_astra_matrix3x3>(),
        4usize,
        concat!("Alignment of ", stringify!(_astra_matrix3x3))
    );
}
pub type astra_matrix3x3_t = _astra_matrix3x3;
pub const astra_core_stream_types_ASTRA_STREAM_DEPTH: astra_core_stream_types = 1;
pub const astra_core_stream_types_ASTRA_STREAM_COLOR: astra_core_stream_types = 2;
pub const astra_core_stream_types_ASTRA_STREAM_INFRARED: astra_core_stream_types = 3;
pub const astra_core_stream_types_ASTRA_STREAM_HAND: astra_core_stream_types = 4;
pub const astra_core_stream_types_ASTRA_STREAM_BODY: astra_core_stream_types = 5;
pub const astra_core_stream_types_ASTRA_STREAM_STYLIZED_DEPTH: astra_core_stream_types = 6;
pub const astra_core_stream_types_ASTRA_STREAM_POINT: astra_core_stream_types = 7;
pub const astra_core_stream_types_ASTRA_STREAM_MASKED_COLOR: astra_core_stream_types = 8;
pub const astra_core_stream_types_ASTRA_STREAM_COLORIZED_BODY: astra_core_stream_types = 9;
pub const astra_core_stream_types_ASTRA_STREAM_DEBUG_HAND: astra_core_stream_types = 3001;
pub type astra_core_stream_types = u32;
#[doc = " \\brief Head"]
pub const _astra_joint_type_ASTRA_JOINT_HEAD: _astra_joint_type = 0;
#[doc = " \\brief Shoulder spine"]
pub const _astra_joint_type_ASTRA_JOINT_SHOULDER_SPINE: _astra_joint_type = 1;
#[doc = " \\brief Left Shoulder"]
pub const _astra_joint_type_ASTRA_JOINT_LEFT_SHOULDER: _astra_joint_type = 2;
#[doc = " \\brief Left Elbow"]
pub const _astra_joint_type_ASTRA_JOINT_LEFT_ELBOW: _astra_joint_type = 3;
#[doc = " \\brief Left Hand"]
pub const _astra_joint_type_ASTRA_JOINT_LEFT_HAND: _astra_joint_type = 4;
#[doc = " \\brief Right Shoulder"]
pub const _astra_joint_type_ASTRA_JOINT_RIGHT_SHOULDER: _astra_joint_type = 5;
#[doc = " \\brief Right Elbow"]
pub const _astra_joint_type_ASTRA_JOINT_RIGHT_ELBOW: _astra_joint_type = 6;
#[doc = " \\brief Right Hand"]
pub const _astra_joint_type_ASTRA_JOINT_RIGHT_HAND: _astra_joint_type = 7;
#[doc = " \\brief Mid spine"]
pub const _astra_joint_type_ASTRA_JOINT_MID_SPINE: _astra_joint_type = 8;
#[doc = " \\brief Base spine"]
pub const _astra_joint_type_ASTRA_JOINT_BASE_SPINE: _astra_joint_type = 9;
#[doc = " \\brief Left Hip"]
pub const _astra_joint_type_ASTRA_JOINT_LEFT_HIP: _astra_joint_type = 10;
#[doc = " \\brief Left Knee"]
pub const _astra_joint_type_ASTRA_JOINT_LEFT_KNEE: _astra_joint_type = 11;
#[doc = " \\brief Left Foot"]
pub const _astra_joint_type_ASTRA_JOINT_LEFT_FOOT: _astra_joint_type = 12;
#[doc = " \\brief Right Hip"]
pub const _astra_joint_type_ASTRA_JOINT_RIGHT_HIP: _astra_joint_type = 13;
#[doc = " \\brief Rigth Knee"]
pub const _astra_joint_type_ASTRA_JOINT_RIGHT_KNEE: _astra_joint_type = 14;
#[doc = " \\brief Right Foot"]
pub const _astra_joint_type_ASTRA_JOINT_RIGHT_FOOT: _astra_joint_type = 15;
#[doc = " \\brief Left Wrist"]
pub const _astra_joint_type_ASTRA_JOINT_LEFT_WRIST: _astra_joint_type = 16;
#[doc = " \\brief Right Wrist"]
pub const _astra_joint_type_ASTRA_JOINT_RIGHT_WRIST: _astra_joint_type = 17;
#[doc = " \\brief Neck"]
pub const _astra_joint_type_ASTRA_JOINT_NECK: _astra_joint_type = 18;
#[doc = " \\brief Unknown"]
pub const _astra_joint_type_ASTRA_JOINT_UNKNOWN: _astra_joint_type = 255;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Joint type enumeration"]
pub type _astra_joint_type = u32;
pub use self::_astra_joint_type as astra_joint_type_v;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Joint type value"]
#[doc = ""]
#[doc = "Values coincide with enum \\ref astra_joint_type_v"]
#[doc = "\\see astra_joint_type_v for possible values"]
pub type astra_joint_type_t = u8;
#[doc = " \\brief Joint not currently tracked"]
pub const _astra_joint_status_ASTRA_JOINT_STATUS_NOT_TRACKED: _astra_joint_status = 0;
#[doc = "\\brief Joint is currently tracked"]
#[doc = "with low confidence possibly due to an occlusion"]
pub const _astra_joint_status_ASTRA_JOINT_STATUS_LOW_CONFIDENCE: _astra_joint_status = 1;
#[doc = " \\brief Joint is currently tracked"]
pub const _astra_joint_status_ASTRA_JOINT_STATUS_TRACKED: _astra_joint_status = 2;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Joint status enumeration"]
pub type _astra_joint_status = u32;
pub use self::_astra_joint_status as astra_joint_status_v;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Joint status type value"]
#[doc = ""]
#[doc = "Values coincide with \\ref astra_joint_status_v"]
#[doc = "\\see astra_joint_status_v for possible values"]
pub type astra_joint_status_t = u8;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Joint information"]
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct _astra_joint {
    #[doc = "\\brief Joint type"]
    #[doc = "\\see astra_joint_type_v for potential values"]
    pub type_: astra_joint_type_t,
    #[doc = "\\brief Joint status"]
    #[doc = "\\see astra_joint_status_v for potential values"]
    pub status: astra_joint_status_t,
    #[doc = " \\brief Depth (\"projective\") position of joint"]
    pub depthPosition: astra_vector2f_t,
    #[doc = " \\brief Real world position of joint"]
    pub worldPosition: astra_vector3f_t,
    #[doc = " \\brief 3x3 Rotation matrix representing the rotation of this joint."]
    pub orientation: astra_matrix3x3_t,
}
#[test]
fn bindgen_test_layout__astra_joint() {
    assert_eq!(
        ::std::mem::size_of::<_astra_joint>(),
        60usize,
        concat!("Size of: ", stringify!(_astra_joint))
    );
    assert_eq!(
        ::std::mem::align_of::<_astra_joint>(),
        4usize,
        concat!("Alignment of ", stringify!(_astra_joint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_joint>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_joint),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_joint>())).status as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_joint),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_joint>())).depthPosition as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_joint),
            "::",
            stringify!(depthPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_joint>())).worldPosition as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_joint),
            "::",
            stringify!(worldPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_joint>())).orientation as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_joint),
            "::",
            stringify!(orientation)
        )
    );
}
pub type astra_joint_t = _astra_joint;
#[doc = " Body is not currently tracked"]
pub const _astra_body_status_ASTRA_BODY_STATUS_NOT_TRACKING: _astra_body_status = 0;
#[doc = " Tracking of body was lost"]
pub const _astra_body_status_ASTRA_BODY_STATUS_LOST: _astra_body_status = 1;
#[doc = " Tracking of body has begun"]
pub const _astra_body_status_ASTRA_BODY_STATUS_TRACKING_STARTED: _astra_body_status = 2;
#[doc = " Body is currently being tracked"]
pub const _astra_body_status_ASTRA_BODY_STATUS_TRACKING: _astra_body_status = 3;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Body tracking status enum"]
pub type _astra_body_status = u32;
pub use self::_astra_body_status as astra_body_status_v;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Body status"]
#[doc = "Values coincide with enum \\ref astra_body_status_v"]
#[doc = ""]
#[doc = "\\see astra_body_status_v for possible values"]
pub type astra_body_status_t = u8;
#[doc = " Hand pose is not known or unrecognized"]
pub const _astra_handpose_ASTRA_HANDPOSE_UNKNOWN: _astra_handpose = 0;
#[doc = " Grip pose"]
pub const _astra_handpose_ASTRA_HANDPOSE_GRIP: _astra_handpose = 1;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Hand pose enum."]
#[doc = "Enumeration of the hand poses that can be detected."]
pub type _astra_handpose = u32;
pub use self::_astra_handpose as astra_handpose_v;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Represents the currently detected hand pose"]
#[doc = ""]
#[doc = "\\see astra_handpose_v for possible values"]
pub type astra_handpose_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone, Default)]
pub struct _astra_handpose_info {
    pub leftHand: astra_handpose_t,
    pub rightHand: astra_handpose_t,
}
#[test]
fn bindgen_test_layout__astra_handpose_info() {
    assert_eq!(
        ::std::mem::size_of::<_astra_handpose_info>(),
        2usize,
        concat!("Size of: ", stringify!(_astra_handpose_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_astra_handpose_info>(),
        1usize,
        concat!("Alignment of ", stringify!(_astra_handpose_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_handpose_info>())).leftHand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_handpose_info),
            "::",
            stringify!(leftHand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_handpose_info>())).rightHand as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_handpose_info),
            "::",
            stringify!(rightHand)
        )
    );
}
pub type astra_handpose_info_t = _astra_handpose_info;
#[doc = " No features beyond minimal body mask segmentation"]
pub const _astra_body_features_ASTRA_BODY_TRACKING_SEGMENTATION: _astra_body_features = 0;
#[doc = " Tracking of joints"]
pub const _astra_body_features_ASTRA_BODY_TRACKING_JOINTS: _astra_body_features = 1;
#[doc = " Recognition of hand poses"]
pub const _astra_body_features_ASTRA_BODY_TRACKING_HAND_POSES: _astra_body_features = 3;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Bitmask of body features"]
#[doc = "Represents the possible features that body tracking can produce"]
#[doc = "on a body. This is a bitmask so multiple features can be combined."]
pub type _astra_body_features = u32;
pub use self::_astra_body_features as astra_body_tracking_feature_flags_v;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Represents a bitmask of body features"]
#[doc = ""]
#[doc = "\\see astra_body_tracking_feature_flags_v for possible values"]
pub type astra_body_tracking_feature_flags_t = u32;
#[doc = " All supported joints"]
pub const _astra_skeleton_profile_ASTRA_SKELETON_PROFILE_FULL: _astra_skeleton_profile = 0;
#[doc = " Upper body only"]
pub const _astra_skeleton_profile_ASTRA_SKELETON_PROFILE_UPPER_BODY: _astra_skeleton_profile = 1;
#[doc = " Only four basic joints: Head, MidSpine, LeftHand, RightHand"]
pub const _astra_skeleton_profile_ASTRA_SKELETON_PROFILE_BASIC: _astra_skeleton_profile = 2;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Skeleton profile representing the set of joints to be tracked."]
pub type _astra_skeleton_profile = u32;
pub use self::_astra_skeleton_profile as astra_skeleton_profile_v;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Skeleton profile representing the set of joints to be tracked."]
#[doc = ""]
#[doc = "\\see astra_skeleton_profile_v for possible values;"]
pub type astra_skeleton_profile_t = u32;
pub const _astra_skeleton_optimization_ASTRA_SKELETON_OPTIMIZATION_1: _astra_skeleton_optimization =
    1;
#[doc = " Configuration that minimizes memory usage at a cost of lower tracking accuracy"]
pub const _astra_skeleton_optimization_ASTRA_SKELETON_OPTIMIZATION_MINIMIZE_MEMORY:
    _astra_skeleton_optimization = 2;
#[doc = " Configuration that minimizes memory usage at a cost of lower tracking accuracy"]
pub const _astra_skeleton_optimization_ASTRA_SKELETON_OPTIMIZATION_2: _astra_skeleton_optimization =
    2;
#[doc = " Configuration that minimizes memory usage at a cost of lower tracking accuracy"]
pub const _astra_skeleton_optimization_ASTRA_SKELETON_OPTIMIZATION_3: _astra_skeleton_optimization =
    3;
#[doc = " Configuration that minimizes memory usage at a cost of lower tracking accuracy"]
pub const _astra_skeleton_optimization_ASTRA_SKELETON_OPTIMIZATION_4: _astra_skeleton_optimization =
    4;
#[doc = " Configuration that balances accuracy with lower memory and CPU usage"]
pub const _astra_skeleton_optimization_ASTRA_SKELETON_OPTIMIZATION_BALANCED:
    _astra_skeleton_optimization = 5;
#[doc = " Configuration that balances accuracy with lower memory and CPU usage"]
pub const _astra_skeleton_optimization_ASTRA_SKELETON_OPTIMIZATION_5: _astra_skeleton_optimization =
    5;
#[doc = " Configuration that balances accuracy with lower memory and CPU usage"]
pub const _astra_skeleton_optimization_ASTRA_SKELETON_OPTIMIZATION_6: _astra_skeleton_optimization =
    6;
#[doc = " Configuration that balances accuracy with lower memory and CPU usage"]
pub const _astra_skeleton_optimization_ASTRA_SKELETON_OPTIMIZATION_7: _astra_skeleton_optimization =
    7;
#[doc = " Configuration that balances accuracy with lower memory and CPU usage"]
pub const _astra_skeleton_optimization_ASTRA_SKELETON_OPTIMIZATION_8: _astra_skeleton_optimization =
    8;
#[doc = " Configuration that balances accuracy with lower memory and CPU usage"]
pub const _astra_skeleton_optimization_ASTRA_SKELETON_OPTIMIZATION_9: _astra_skeleton_optimization =
    9;
#[doc = " Configuration that produces the best tracking accuracy"]
pub const _astra_skeleton_optimization_ASTRA_SKELETON_OPTIMIZATION_BEST_ACCURACY:
    _astra_skeleton_optimization = 9;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Represents the body tracking configuration that trades-off"]
#[doc = "tracking accuracy, memory, and CPU usage."]
pub type _astra_skeleton_optimization = u32;
pub use self::_astra_skeleton_optimization as astra_skeleton_optimization_v;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Represents the body tracking configuration that trades-off"]
#[doc = "tracking accuracy, memory, and CPU usage."]
#[doc = ""]
#[doc = "\\see astra_skeleton_optimization_v for possible values;"]
pub type astra_skeleton_optimization_t = u32;
pub const _astra_body_orientation_ASTRA_BODY_ORIENTATION_TOP: _astra_body_orientation = 0;
pub const _astra_body_orientation_ASTRA_BODY_ORIENTATION_LEFT: _astra_body_orientation = 1;
pub const _astra_body_orientation_ASTRA_BODY_ORIENTATION_RIGHT: _astra_body_orientation = 2;
pub type _astra_body_orientation = u32;
pub use self::_astra_body_orientation as astra_body_orientation_v;
pub type astra_body_orientation_t = u32;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Body identifier"]
pub type astra_body_id_t = u8;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Struct containing body tracking information"]
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct _astra_body {
    #[doc = " \\brief Bitmask of features that are enabled."]
    #[doc = ""]
    #[doc = "\\see astra_body_tracking_feature_flags_v for possible values"]
    pub features: astra_body_tracking_feature_flags_t,
    #[doc = " \\brief Single point describing the center of mass of a body."]
    #[doc = ""]
    #[doc = "Always present, even if \\ref ASTRA_BODY_TRACKING_JOINTS is not enabled."]
    #[doc = "Useful for doing general calculations about the relative positions of bodies."]
    pub centerOfMass: astra_vector3f_t,
    #[doc = " \\brief Array of tracked joints"]
    pub joints: [astra_joint_t; 19usize],
    #[doc = " \\brief Hand poses"]
    pub handPoses: astra_handpose_info_t,
    #[doc = " \\brief Persistent Id"]
    #[doc = ""]
    #[doc = "An astra_body_id_t value can be used to match a particular"]
    #[doc = "active astra_body_t across frames. Additionally, \\ref astra_body_id_t"]
    #[doc = "values match the values in a \\ref astra_bodymask_t"]
    pub id: astra_body_id_t,
    #[doc = "\\brief Tracking status"]
    #[doc = ""]
    #[doc = "\\see astra_body_status_v for possible values"]
    pub status: astra_body_status_t,
}
#[test]
fn bindgen_test_layout__astra_body() {
    assert_eq!(
        ::std::mem::size_of::<_astra_body>(),
        1160usize,
        concat!("Size of: ", stringify!(_astra_body))
    );
    assert_eq!(
        ::std::mem::align_of::<_astra_body>(),
        4usize,
        concat!("Alignment of ", stringify!(_astra_body))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_body>())).features as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_body),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_body>())).centerOfMass as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_body),
            "::",
            stringify!(centerOfMass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_body>())).joints as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_body),
            "::",
            stringify!(joints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_body>())).handPoses as *const _ as usize },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_body),
            "::",
            stringify!(handPoses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_body>())).id as *const _ as usize },
        1158usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_body),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_body>())).status as *const _ as usize },
        1159usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_body),
            "::",
            stringify!(status)
        )
    );
}
pub type astra_body_t = _astra_body;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Struct containing a variable-sized"]
#[doc = "array of \\ref astra_body_t structs"]
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct _astra_body_list {
    pub bodies: [astra_body_t; 6usize],
    #[doc = " \\brief Number of astra_body_t in bodies"]
    pub count: i32,
}
#[test]
fn bindgen_test_layout__astra_body_list() {
    assert_eq!(
        ::std::mem::size_of::<_astra_body_list>(),
        6964usize,
        concat!("Size of: ", stringify!(_astra_body_list))
    );
    assert_eq!(
        ::std::mem::align_of::<_astra_body_list>(),
        4usize,
        concat!("Alignment of ", stringify!(_astra_body_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_body_list>())).bodies as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_body_list),
            "::",
            stringify!(bodies)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_body_list>())).count as *const _ as usize },
        6960usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_body_list),
            "::",
            stringify!(count)
        )
    );
}
pub type astra_body_list_t = _astra_body_list;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Struct representing a 2-dimensional bitmask"]
#[doc = ""]
#[doc = "A mask pixel is a uint8_t. All non-zero values are considered"]
#[doc = "to be part of the mask."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _astra_bitmapmask {
    pub data: [u8; 307200usize],
    #[doc = " \\brief width in pixels"]
    pub width: i32,
    #[doc = " \\brief height in pixels"]
    pub height: i32,
}
#[test]
fn bindgen_test_layout__astra_bitmapmask() {
    assert_eq!(
        ::std::mem::size_of::<_astra_bitmapmask>(),
        307208usize,
        concat!("Size of: ", stringify!(_astra_bitmapmask))
    );
    assert_eq!(
        ::std::mem::align_of::<_astra_bitmapmask>(),
        4usize,
        concat!("Alignment of ", stringify!(_astra_bitmapmask))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_bitmapmask>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_bitmapmask),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_bitmapmask>())).width as *const _ as usize },
        307200usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_bitmapmask),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_bitmapmask>())).height as *const _ as usize },
        307204usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_bitmapmask),
            "::",
            stringify!(height)
        )
    );
}
pub type astra_bitmapmask_t = _astra_bitmapmask;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Represents a 2-dimensional bitmask of bodies"]
#[doc = ""]
#[doc = "Non-zero values map to the \\ref astra_body_id_t of a astra_body_t"]
#[doc = "\\see astra_body_t for more info on a body's id"]
#[doc = "\\see astra_bitmapmask_t for available struct fields"]
pub type astra_bodymask_t = astra_bitmapmask_t;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Represents a 2-dimensional bitmask of floor pixels"]
#[doc = ""]
#[doc = "Non-zero values are considered to belong to the floor"]
#[doc = "\\see astra_bitmapmask_t for available struct fields"]
pub type astra_floormask_t = astra_bitmapmask_t;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Struct representing a geometric 3-dimensional plane"]
#[doc = ""]
#[doc = "The normal of the plane is defined to be (A, B, C). The plane coefficients and real world"]
#[doc = "coordinates (x, y, and z) are related by the plane equation:"]
#[doc = ""]
#[doc = "Ax + By + Cz + D = 0"]
#[doc = ""]
#[doc = "\\remark The vector v = (A, B, C) represents the normal to the plane and"]
#[doc = "D represents the signed distance along the normal between the plane and the origin"]
#[doc = "of the coordinate system. The the origin of the coordinate system is the camera's"]
#[doc = "depth sensor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _astra_plane {
    #[doc = " \\brief A coefficient"]
    pub a: f32,
    #[doc = " \\brief B coefficient"]
    pub b: f32,
    #[doc = " \\brief C coefficient"]
    pub c: f32,
    #[doc = " \\brief D coefficient"]
    pub d: f32,
}
#[test]
fn bindgen_test_layout__astra_plane() {
    assert_eq!(
        ::std::mem::size_of::<_astra_plane>(),
        16usize,
        concat!("Size of: ", stringify!(_astra_plane))
    );
    assert_eq!(
        ::std::mem::align_of::<_astra_plane>(),
        4usize,
        concat!("Alignment of ", stringify!(_astra_plane))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_plane>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_plane),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_plane>())).b as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_plane),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_plane>())).c as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_plane),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_plane>())).d as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_plane),
            "::",
            stringify!(d)
        )
    );
}
pub type astra_plane_t = _astra_plane;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Struct containing general body frame information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _astra_bodyframe_info {
    #[doc = " \\brief Frame width"]
    pub width: i32,
    #[doc = " \\brief Frame height"]
    pub height: i32,
    #[doc = " \\brief If the frame was estimated due to a slow CPU"]
    pub isEstimated: i8,
}
#[test]
fn bindgen_test_layout__astra_bodyframe_info() {
    assert_eq!(
        ::std::mem::size_of::<_astra_bodyframe_info>(),
        12usize,
        concat!("Size of: ", stringify!(_astra_bodyframe_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_astra_bodyframe_info>(),
        4usize,
        concat!("Alignment of ", stringify!(_astra_bodyframe_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_bodyframe_info>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_bodyframe_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_bodyframe_info>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_bodyframe_info),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_astra_bodyframe_info>())).isEstimated as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_bodyframe_info),
            "::",
            stringify!(isEstimated)
        )
    );
}
pub type astra_bodyframe_info_t = _astra_bodyframe_info;
#[doc = "\\ingroup CTypes"]
#[doc = "\\brief Struct containing floor information about the scene"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _astra_floor_info {
    #[doc = " \\brief Floor mask"]
    pub floorMask: astra_floormask_t,
    #[doc = " \\brief Floor plane"]
    pub floorPlane: astra_plane_t,
    #[doc = " \\brief If the floor is detected, ASTRA_TRUE. Otherwise, ASTRA_FALSE."]
    #[doc = ""]
    #[doc = "If a floor is not detected, floorPlane and floorMask will not contain"]
    #[doc = "meaningful data."]
    pub floorDetected: astra_bool_t,
}
#[test]
fn bindgen_test_layout__astra_floor_info() {
    assert_eq!(
        ::std::mem::size_of::<_astra_floor_info>(),
        307228usize,
        concat!("Size of: ", stringify!(_astra_floor_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_astra_floor_info>(),
        4usize,
        concat!("Alignment of ", stringify!(_astra_floor_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_floor_info>())).floorMask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_floor_info),
            "::",
            stringify!(floorMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_floor_info>())).floorPlane as *const _ as usize },
        307208usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_floor_info),
            "::",
            stringify!(floorPlane)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_astra_floor_info>())).floorDetected as *const _ as usize },
        307224usize,
        concat!(
            "Offset of field: ",
            stringify!(_astra_floor_info),
            "::",
            stringify!(floorDetected)
        )
    );
}
pub type astra_floor_info_t = _astra_floor_info;
#[repr(C)]
#[derive(Debug, Copy, Clone, Default)]
pub struct _astra_bodyframe {
    _unused: [u8; 0],
}
pub type astra_bodyframe_t = *mut _astra_bodyframe;
pub type astra_bodystream_t = astra_streamconnection_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct astra_body_feature_command_t {
    pub bodyId: astra_body_id_t,
    pub feature: astra_body_tracking_feature_flags_t,
}
#[test]
fn bindgen_test_layout_astra_body_feature_command_t() {
    assert_eq!(
        ::std::mem::size_of::<astra_body_feature_command_t>(),
        8usize,
        concat!("Size of: ", stringify!(astra_body_feature_command_t))
    );
    assert_eq!(
        ::std::mem::align_of::<astra_body_feature_command_t>(),
        4usize,
        concat!("Alignment of ", stringify!(astra_body_feature_command_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_body_feature_command_t>())).bodyId as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_body_feature_command_t),
            "::",
            stringify!(bodyId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_body_feature_command_t>())).feature as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_body_feature_command_t),
            "::",
            stringify!(feature)
        )
    );
}
extern "C" {
    pub fn astra_reader_get_bodystream(
        reader: astra_reader_t,
        bodyStream: *mut astra_bodystream_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodystream_is_available(
        bodyStream: astra_bodystream_t,
        isAvailable: *mut bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodystream_get_body_features(
        bodyStream: astra_bodystream_t,
        id: astra_body_id_t,
        features: *mut astra_body_tracking_feature_flags_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodystream_set_body_features(
        bodyStream: astra_bodystream_t,
        id: astra_body_id_t,
        features: astra_body_tracking_feature_flags_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodystream_get_default_body_features(
        bodyStream: astra_bodystream_t,
        features: *mut astra_body_tracking_feature_flags_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodystream_set_default_body_features(
        bodyStream: astra_bodystream_t,
        features: astra_body_tracking_feature_flags_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodystream_get_skeleton_profile(
        bodyStream: astra_bodystream_t,
        skeletonProfile: *mut astra_skeleton_profile_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodystream_set_skeleton_profile(
        bodyStream: astra_bodystream_t,
        skeletonProfile: astra_skeleton_profile_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodystream_get_skeleton_optimization(
        bodyStream: astra_bodystream_t,
        skeletonOptimization: *mut astra_skeleton_optimization_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodystream_set_skeleton_optimization(
        bodyStream: astra_bodystream_t,
        skeletonOptimization: astra_skeleton_optimization_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodystream_get_body_orientation(
        bodyStream: astra_bodystream_t,
        bodyOrientation: *mut astra_body_orientation_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodystream_set_body_orientation(
        bodyStream: astra_bodystream_t,
        bodyOrientation: astra_body_orientation_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_frame_get_bodyframe(
        readerFrame: astra_reader_frame_t,
        bodyFrame: *mut astra_bodyframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodyframe_get_frameindex(
        bodyFrame: astra_bodyframe_t,
        index: *mut astra_frame_index_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodyframe_info(
        bodyFrame: astra_bodyframe_t,
        info: *mut astra_bodyframe_info_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodyframe_bodymask(
        bodyFrame: astra_bodyframe_t,
        bodyMask: *mut astra_bodymask_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodyframe_bodymask_ptr(
        bodyFrame: astra_bodyframe_t,
        width: *mut u32,
        height: *mut u32,
        dataPtr: *mut *mut ::std::os::raw::c_void,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodyframe_copy_bodymask_data(
        bodyFrame: astra_bodyframe_t,
        data: *mut ::std::os::raw::c_void,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodyframe_floor_info(
        bodyFrame: astra_bodyframe_t,
        floorInfo: *mut astra_floor_info_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodyframe_floormask_ptr(
        bodyFrame: astra_bodyframe_t,
        width: *mut u32,
        height: *mut u32,
        dataPtr: *mut *mut ::std::os::raw::c_void,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodyframe_copy_floormask_data(
        bodyFrame: astra_bodyframe_t,
        data: *mut ::std::os::raw::c_void,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodyframe_floor_info_ptr(
        bodyFrame: astra_bodyframe_t,
        floorInfo: *mut *mut astra_floor_info_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodyframe_body_list(
        bodyFrame: astra_bodyframe_t,
        bodyList: *mut astra_body_list_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_bodyframe_rotate(
        bodyFrame: astra_bodyframe_t,
        angle: ::std::os::raw::c_int,
    ) -> astra_status_t;
}
extern "C" {
    pub fn orbbec_body_tracking_set_license(
        licenseString: *const ::std::os::raw::c_char,
    ) -> astra_status_t;
}
pub type astra_pixel_format_t = u32;
pub const astra_pixel_formats_ASTRA_PIXEL_FORMAT_UNKNOWN: astra_pixel_formats = 0;
pub const astra_pixel_formats_ASTRA_PIXEL_FORMAT_DEPTH_MM: astra_pixel_formats = 100;
pub const astra_pixel_formats_ASTRA_PIXEL_FORMAT_RGB888: astra_pixel_formats = 200;
pub const astra_pixel_formats_ASTRA_PIXEL_FORMAT_YUV422: astra_pixel_formats = 201;
pub const astra_pixel_formats_ASTRA_PIXEL_FORMAT_YUYV: astra_pixel_formats = 202;
pub const astra_pixel_formats_ASTRA_PIXEL_FORMAT_RGBA: astra_pixel_formats = 203;
pub const astra_pixel_formats_ASTRA_PIXEL_FORMAT_NV21: astra_pixel_formats = 204;
pub const astra_pixel_formats_ASTRA_PIXEL_FORMAT_GRAY8: astra_pixel_formats = 300;
pub const astra_pixel_formats_ASTRA_PIXEL_FORMAT_GRAY16: astra_pixel_formats = 301;
pub const astra_pixel_formats_ASTRA_PIXEL_FORMAT_POINT: astra_pixel_formats = 400;
pub type astra_pixel_formats = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone, Default)]
pub struct astra_rgb_pixel_t {
    pub r: u8,
    pub g: u8,
    pub b: u8,
}
#[test]
fn bindgen_test_layout_astra_rgb_pixel_t() {
    assert_eq!(
        ::std::mem::size_of::<astra_rgb_pixel_t>(),
        3usize,
        concat!("Size of: ", stringify!(astra_rgb_pixel_t))
    );
    assert_eq!(
        ::std::mem::align_of::<astra_rgb_pixel_t>(),
        1usize,
        concat!("Alignment of ", stringify!(astra_rgb_pixel_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_rgb_pixel_t>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_rgb_pixel_t),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_rgb_pixel_t>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_rgb_pixel_t),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_rgb_pixel_t>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_rgb_pixel_t),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct astra_rgba_pixel_t {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub alpha: u8,
}
#[test]
fn bindgen_test_layout_astra_rgba_pixel_t() {
    assert_eq!(
        ::std::mem::size_of::<astra_rgba_pixel_t>(),
        4usize,
        concat!("Size of: ", stringify!(astra_rgba_pixel_t))
    );
    assert_eq!(
        ::std::mem::align_of::<astra_rgba_pixel_t>(),
        1usize,
        concat!("Alignment of ", stringify!(astra_rgba_pixel_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_rgba_pixel_t>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_rgba_pixel_t),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_rgba_pixel_t>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_rgba_pixel_t),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_rgba_pixel_t>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_rgba_pixel_t),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_rgba_pixel_t>())).alpha as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_rgba_pixel_t),
            "::",
            stringify!(alpha)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Default)]
pub struct astra_image_metadata_t {
    pub width: u32,
    pub height: u32,
    pub pixelFormat: astra_pixel_format_t,
}
#[test]
fn bindgen_test_layout_astra_image_metadata_t() {
    assert_eq!(
        ::std::mem::size_of::<astra_image_metadata_t>(),
        12usize,
        concat!("Size of: ", stringify!(astra_image_metadata_t))
    );
    assert_eq!(
        ::std::mem::align_of::<astra_image_metadata_t>(),
        4usize,
        concat!("Alignment of ", stringify!(astra_image_metadata_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_image_metadata_t>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_image_metadata_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_image_metadata_t>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_image_metadata_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_image_metadata_t>())).pixelFormat as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_image_metadata_t),
            "::",
            stringify!(pixelFormat)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct astra_imagestream_mode_t {
    pub id: u32,
    pub width: u32,
    pub height: u32,
    pub pixelFormat: astra_pixel_format_t,
    pub fps: u8,
}
#[test]
fn bindgen_test_layout_astra_imagestream_mode_t() {
    assert_eq!(
        ::std::mem::size_of::<astra_imagestream_mode_t>(),
        20usize,
        concat!("Size of: ", stringify!(astra_imagestream_mode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<astra_imagestream_mode_t>(),
        4usize,
        concat!("Alignment of ", stringify!(astra_imagestream_mode_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_imagestream_mode_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_imagestream_mode_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_imagestream_mode_t>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_imagestream_mode_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_imagestream_mode_t>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_imagestream_mode_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_imagestream_mode_t>())).pixelFormat as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_imagestream_mode_t),
            "::",
            stringify!(pixelFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_imagestream_mode_t>())).fps as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_imagestream_mode_t),
            "::",
            stringify!(fps)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Default)]
pub struct _astra_imageframe {
    _unused: [u8; 0],
}
pub type astra_imageframe_t = *mut _astra_imageframe;
pub type astra_imagestream_t = astra_streamconnection_t;
extern "C" {
    pub fn astra_imagestream_get_mirroring(
        imageStream: astra_imagestream_t,
        mirroring: *mut bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_imagestream_set_mirroring(
        imageStream: astra_imagestream_t,
        mirroring: bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_imagestream_get_hfov(
        imageStream: astra_imagestream_t,
        hFov: *mut f32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_imagestream_get_vfov(
        imageStream: astra_imagestream_t,
        vFov: *mut f32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_imagestream_get_usb_info(
        imageStream: astra_imagestream_t,
        usbInfo: *mut astra_usb_info_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_imagestream_request_modes(
        imageStream: astra_imagestream_t,
        token: *mut astra_result_token_t,
        count: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_imagestream_get_modes_result(
        imageStream: astra_imagestream_t,
        token: astra_result_token_t,
        modes: *mut astra_imagestream_mode_t,
        count: u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_imagestream_get_mode(
        imageStream: astra_imagestream_t,
        mode: *mut astra_imagestream_mode_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_imagestream_set_mode(
        imageStream: astra_imagestream_t,
        mode: *const astra_imagestream_mode_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_reader_get_imageframe(
        readerFrame: astra_reader_frame_t,
        type_: astra_stream_type_t,
        subtype: astra_stream_subtype_t,
        imageFrame: *mut astra_imageframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_imageframe_get_stream(
        imageFrame: astra_imageframe_t,
        stream: *mut astra_streamconnection_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_imageframe_get_frameindex(
        imageFrame: astra_imageframe_t,
        index: *mut astra_frame_index_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_imageframe_get_data_byte_length(
        imageFrame: astra_imageframe_t,
        byteLength: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_imageframe_get_data_ptr(
        imageFrame: astra_imageframe_t,
        data: *mut *mut ::std::os::raw::c_void,
        byteLength: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_imageframe_copy_data(
        imageFrame: astra_imageframe_t,
        data: *mut ::std::os::raw::c_void,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_imageframe_get_metadata(
        imageFrame: astra_imageframe_t,
        metadata: *mut astra_image_metadata_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_imageframe_rotate(
        imageFrame: astra_imageframe_t,
        angle: ::std::os::raw::c_int,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_pixelformat_get_bytes_per_pixel(format: astra_pixel_format_t, bpp: *mut u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct astra_conversion_cache_t {
    pub xzFactor: f32,
    pub yzFactor: f32,
    pub coeffX: f32,
    pub coeffY: f32,
    pub resolutionX: ::std::os::raw::c_int,
    pub resolutionY: ::std::os::raw::c_int,
    pub halfResX: ::std::os::raw::c_int,
    pub halfResY: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_astra_conversion_cache_t() {
    assert_eq!(
        ::std::mem::size_of::<astra_conversion_cache_t>(),
        32usize,
        concat!("Size of: ", stringify!(astra_conversion_cache_t))
    );
    assert_eq!(
        ::std::mem::align_of::<astra_conversion_cache_t>(),
        4usize,
        concat!("Alignment of ", stringify!(astra_conversion_cache_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_conversion_cache_t>())).xzFactor as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_conversion_cache_t),
            "::",
            stringify!(xzFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_conversion_cache_t>())).yzFactor as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_conversion_cache_t),
            "::",
            stringify!(yzFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_conversion_cache_t>())).coeffX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_conversion_cache_t),
            "::",
            stringify!(coeffX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_conversion_cache_t>())).coeffY as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_conversion_cache_t),
            "::",
            stringify!(coeffY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_conversion_cache_t>())).resolutionX as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_conversion_cache_t),
            "::",
            stringify!(resolutionX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_conversion_cache_t>())).resolutionY as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_conversion_cache_t),
            "::",
            stringify!(resolutionY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_conversion_cache_t>())).halfResX as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_conversion_cache_t),
            "::",
            stringify!(halfResX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_conversion_cache_t>())).halfResY as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_conversion_cache_t),
            "::",
            stringify!(halfResY)
        )
    );
}
pub type astra_depthstream_t = astra_streamconnection_t;
pub type astra_depthframe_t = *mut _astra_imageframe;
extern "C" {
    pub fn astra_convert_depth_to_world(
        depthStream: astra_depthstream_t,
        depthX: f32,
        depthY: f32,
        depthZ: f32,
        pWorldX: *mut f32,
        pWorldY: *mut f32,
        pWorldZ: *mut f32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_convert_world_to_depth(
        depthStream: astra_depthstream_t,
        worldX: f32,
        worldY: f32,
        worldZ: f32,
        pDepthX: *mut f32,
        pDepthY: *mut f32,
        pDepthZ: *mut f32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_reader_get_depthstream(
        reader: astra_reader_t,
        depthStream: *mut astra_depthstream_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_depthstream_is_available(
        depthStream: astra_depthstream_t,
        isAvailable: *mut bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_depthstream_get_depth_to_world_data(
        depthStream: astra_depthstream_t,
        conversionData: *mut astra_conversion_cache_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_depthstream_get_hfov(
        depthStream: astra_depthstream_t,
        hFov: *mut f32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_depthstream_get_vfov(
        depthStream: astra_depthstream_t,
        vFov: *mut f32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_depthstream_get_registration(
        depthStream: astra_depthstream_t,
        enabled: *mut bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_depthstream_set_registration(
        depthStream: astra_depthstream_t,
        enabled: bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_depthstream_get_d2c_resolution(
        depthStream: astra_depthstream_t,
        mode: *mut ::std::os::raw::c_int,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_depthstream_set_d2c_resolution(
        depthStream: astra_depthstream_t,
        mode: ::std::os::raw::c_int,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_depthstream_get_serialnumber(
        depthStream: astra_depthstream_t,
        serialnumber: *mut ::std::os::raw::c_char,
        length: u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_depthstream_get_chip_id(
        depthStream: astra_depthstream_t,
        chipId: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_depthstream_get_usb_info(
        depthStream: astra_depthstream_t,
        usbInfo: *mut astra_usb_info_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_frame_get_depthframe(
        readerFrame: astra_reader_frame_t,
        depthFrame: *mut astra_depthframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_frame_get_depthframe_with_subtype(
        readerFrame: astra_reader_frame_t,
        subtype: astra_stream_subtype_t,
        colorFrame: *mut astra_depthframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_depthframe_get_data_byte_length(
        depthFrame: astra_depthframe_t,
        byteLength: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_depthframe_get_data_ptr(
        depthFrame: astra_depthframe_t,
        data: *mut *mut i16,
        byteLength: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_depthframe_copy_data(
        depthFrame: astra_depthframe_t,
        data: *mut i16,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_depthframe_get_metadata(
        depthFrame: astra_depthframe_t,
        metadata: *mut astra_image_metadata_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_depthframe_get_frameindex(
        depthFrame: astra_depthframe_t,
        index: *mut astra_frame_index_t,
    ) -> astra_status_t;
}
pub type astra_colorstream_t = astra_streamconnection_t;
pub type astra_colorframe_t = *mut _astra_imageframe;
extern "C" {
    pub fn astra_reader_get_colorstream(
        reader: astra_reader_t,
        colorStream: *mut astra_colorstream_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_colorstream_is_available(
        colorStream: astra_colorstream_t,
        isAvailable: *mut bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_colorstream_get_usb_info(
        colorStream: astra_colorstream_t,
        usbInfo: *mut astra_usb_info_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_frame_get_colorframe(
        readerFrame: astra_reader_frame_t,
        colorFrame: *mut astra_colorframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_frame_get_colorframe_with_subtype(
        readerFrame: astra_reader_frame_t,
        subtype: astra_stream_subtype_t,
        colorFrame: *mut astra_colorframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_colorframe_get_data_byte_length(
        colorFrame: astra_colorframe_t,
        byteLength: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_colorframe_get_data_ptr(
        colorFrame: astra_colorframe_t,
        data: *mut *mut u8,
        byteLength: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_colorframe_get_data_rgb_ptr(
        colorFrame: astra_colorframe_t,
        data: *mut *mut astra_rgb_pixel_t,
        byteLength: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_colorframe_copy_data(
        colorFrame: astra_colorframe_t,
        data: *mut u8,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_colorframe_get_metadata(
        colorFrame: astra_colorframe_t,
        metadata: *mut astra_image_metadata_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_colorframe_get_frameindex(
        colorFrame: astra_colorframe_t,
        index: *mut astra_frame_index_t,
    ) -> astra_status_t;
}
pub type astra_infraredstream_t = astra_streamconnection_t;
pub type astra_infraredframe_t = *mut _astra_imageframe;
extern "C" {
    pub fn astra_reader_get_infraredstream(
        reader: astra_reader_t,
        infraredstream: *mut astra_infraredstream_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_infraredstream_is_available(
        infraredStream: astra_infraredstream_t,
        isAvailable: *mut bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_infraredstream_get_hfov(
        infraredstream: astra_infraredstream_t,
        hFov: *mut f32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_infraredstream_get_vfov(
        infraredstream: astra_infraredstream_t,
        vFov: *mut f32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_infraredstream_get_usb_info(
        infraredStream: astra_infraredstream_t,
        usbInfo: *mut astra_usb_info_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_frame_get_infraredframe(
        readerFrame: astra_reader_frame_t,
        infraredframe: *mut astra_infraredframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_frame_get_infraredframe_with_subtype(
        readerFrame: astra_reader_frame_t,
        subtype: astra_stream_subtype_t,
        colorFrame: *mut astra_infraredframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_infraredframe_get_data_byte_length(
        infraredframe: astra_infraredframe_t,
        byteLength: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_infraredframe_get_data_ptr(
        infraredframe: astra_infraredframe_t,
        data: *mut *mut u8,
        byteLength: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_infraredframe_copy_data(
        infraredframe: astra_infraredframe_t,
        data: *mut u8,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_infraredframe_get_metadata(
        infraredframe: astra_infraredframe_t,
        metadata: *mut astra_image_metadata_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_infraredframe_get_frameindex(
        infraredframe: astra_infraredframe_t,
        index: *mut astra_frame_index_t,
    ) -> astra_status_t;
}
pub const astra_debug_hand_view_type_t_DEBUG_HAND_VIEW_DEPTH: astra_debug_hand_view_type_t = 0;
pub const astra_debug_hand_view_type_t_DEBUG_HAND_VIEW_VELOCITY: astra_debug_hand_view_type_t = 1;
pub const astra_debug_hand_view_type_t_DEBUG_HAND_VIEW_FILTEREDVELOCITY:
    astra_debug_hand_view_type_t = 2;
pub const astra_debug_hand_view_type_t_DEBUG_HAND_VIEW_UPDATE_SEGMENTATION:
    astra_debug_hand_view_type_t = 3;
pub const astra_debug_hand_view_type_t_DEBUG_HAND_VIEW_CREATE_SEGMENTATION:
    astra_debug_hand_view_type_t = 4;
pub const astra_debug_hand_view_type_t_DEBUG_HAND_VIEW_UPDATE_SEARCHED:
    astra_debug_hand_view_type_t = 5;
pub const astra_debug_hand_view_type_t_DEBUG_HAND_VIEW_CREATE_SEARCHED:
    astra_debug_hand_view_type_t = 6;
pub const astra_debug_hand_view_type_t_DEBUG_HAND_VIEW_CREATE_SCORE: astra_debug_hand_view_type_t =
    7;
pub const astra_debug_hand_view_type_t_DEBUG_HAND_VIEW_UPDATE_SCORE: astra_debug_hand_view_type_t =
    8;
pub const astra_debug_hand_view_type_t_DEBUG_HAND_VIEW_HANDWINDOW: astra_debug_hand_view_type_t = 9;
pub const astra_debug_hand_view_type_t_DEBUG_HAND_VIEW_DEPTH_MOD: astra_debug_hand_view_type_t = 10;
pub const astra_debug_hand_view_type_t_DEBUG_HAND_VIEW_DEPTH_AVG: astra_debug_hand_view_type_t = 11;
pub const astra_debug_hand_view_type_t_DEBUG_HAND_VIEW_TEST_PASS_MAP: astra_debug_hand_view_type_t =
    12;
pub type astra_debug_hand_view_type_t = u32;
pub const astra_handstatus_t_HAND_STATUS_NOTTRACKING: astra_handstatus_t = 0;
pub const astra_handstatus_t_HAND_STATUS_CANDIDATE: astra_handstatus_t = 1;
pub const astra_handstatus_t_HAND_STATUS_TRACKING: astra_handstatus_t = 2;
pub const astra_handstatus_t_HAND_STATUS_LOST: astra_handstatus_t = 3;
pub type astra_handstatus_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct astra_handpoint_t {
    pub trackingId: i32,
    pub status: astra_handstatus_t,
    pub depthPosition: astra_vector2i_t,
    pub worldPosition: astra_vector3f_t,
    pub worldDeltaPosition: astra_vector3f_t,
}
#[test]
fn bindgen_test_layout_astra_handpoint_t() {
    assert_eq!(
        ::std::mem::size_of::<astra_handpoint_t>(),
        40usize,
        concat!("Size of: ", stringify!(astra_handpoint_t))
    );
    assert_eq!(
        ::std::mem::align_of::<astra_handpoint_t>(),
        4usize,
        concat!("Alignment of ", stringify!(astra_handpoint_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_handpoint_t>())).trackingId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_handpoint_t),
            "::",
            stringify!(trackingId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_handpoint_t>())).status as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_handpoint_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_handpoint_t>())).depthPosition as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_handpoint_t),
            "::",
            stringify!(depthPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<astra_handpoint_t>())).worldPosition as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_handpoint_t),
            "::",
            stringify!(worldPosition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<astra_handpoint_t>())).worldDeltaPosition as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(astra_handpoint_t),
            "::",
            stringify!(worldDeltaPosition)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _astra_handframe {
    _unused: [u8; 0],
}
pub type astra_handframe_t = *mut _astra_handframe;
pub type astra_handstream_t = astra_streamconnection_t;
pub type astra_debug_handframe_t = *mut _astra_imageframe;
pub type astra_debug_handstream_t = astra_streamconnection_t;
extern "C" {
    pub fn astra_reader_get_handstream(
        reader: astra_reader_t,
        handStream: *mut astra_handstream_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_handstream_is_available(
        handStream: astra_handstream_t,
        isAvailable: *mut bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_frame_get_handframe(
        readerFrame: astra_reader_frame_t,
        handFrame: *mut astra_handframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_frame_get_handframe_with_subtype(
        readerFrame: astra_reader_frame_t,
        subtype: astra_stream_subtype_t,
        handFrame: *mut astra_handframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_handframe_get_frameindex(
        handFrame: astra_handframe_t,
        index: *mut astra_frame_index_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_handframe_get_hand_count(
        handFrame: astra_handframe_t,
        handCount: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_handframe_copy_hands(
        handFrame: astra_handframe_t,
        handPointsDestination: *mut astra_handpoint_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_handframe_get_shared_hand_array(
        handFrame: astra_handframe_t,
        handpoints: *mut *mut astra_handpoint_t,
        handCount: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_handstream_get_include_candidate_points(
        handStream: astra_handstream_t,
        includeCandidatePoints: *mut bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_handstream_set_include_candidate_points(
        handStream: astra_handstream_t,
        includeCandidatePoints: bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_reader_get_debug_handstream(
        reader: astra_reader_t,
        debugHandStream: *mut astra_debug_handstream_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_frame_get_debug_handframe(
        readerFrame: astra_reader_frame_t,
        debugHandFrame: *mut astra_debug_handframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_debug_handstream_get_view_type(
        debugHandStream: astra_debug_handstream_t,
        viewType: *mut astra_debug_hand_view_type_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_debug_handstream_set_view_type(
        debugHandStream: astra_debug_handstream_t,
        viewType: astra_debug_hand_view_type_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_debug_handstream_set_mouse_position(
        debugHandStream: astra_debug_handstream_t,
        normPosition: astra_vector2f_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_debug_handstream_set_use_mouse_probe(
        debugHandStream: astra_debug_handstream_t,
        useMouseProbe: bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_debug_handstream_set_pause_input(
        debugHandStream: astra_debug_handstream_t,
        pauseInput: bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_debug_handstream_set_lock_spawn_point(
        debugHandStream: astra_debug_handstream_t,
        lockSpawnPoint: bool,
    ) -> astra_status_t;
}
pub type astra_pointstream_t = astra_streamconnection_t;
pub type astra_pointframe_t = *mut _astra_imageframe;
extern "C" {
    pub fn astra_reader_get_pointstream(
        reader: astra_reader_t,
        pointStream: *mut astra_pointstream_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_pointstream_is_available(
        pointStream: astra_pointstream_t,
        isAvailable: *mut bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_frame_get_pointframe(
        readerFrame: astra_reader_frame_t,
        pointFrame: *mut astra_pointframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_frame_get_pointframe_with_subtype(
        readerFrame: astra_reader_frame_t,
        subtype: astra_stream_subtype_t,
        pointFrame: *mut astra_pointframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_pointframe_get_data_byte_length(
        pointFrame: astra_pointframe_t,
        byteLength: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_pointframe_get_data_ptr(
        pointFrame: astra_pointframe_t,
        data: *mut *mut astra_vector3f_t,
        byteLength: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_pointframe_copy_data(
        pointFrame: astra_pointframe_t,
        data: *mut astra_vector3f_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_pointframe_get_metadata(
        pointFrame: astra_pointframe_t,
        metadata: *mut astra_image_metadata_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_pointframe_get_frameindex(
        pointFrame: astra_pointframe_t,
        index: *mut astra_frame_index_t,
    ) -> astra_status_t;
}
pub type astra_maskedcolorstream_t = astra_streamconnection_t;
pub type astra_maskedcolorframe_t = *mut _astra_imageframe;
extern "C" {
    pub fn astra_reader_get_maskedcolorstream(
        reader: astra_reader_t,
        maskedcolorStream: *mut astra_maskedcolorstream_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_maskedcolorstream_is_available(
        maskedcolorStream: astra_maskedcolorstream_t,
        isAvailable: *mut bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_frame_get_maskedcolorframe(
        readerFrame: astra_reader_frame_t,
        maskedcolorFrame: *mut astra_maskedcolorframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_frame_get_maskedcolorframe_with_subtype(
        readerFrame: astra_reader_frame_t,
        subtype: astra_stream_subtype_t,
        maskedcolorFrame: *mut astra_maskedcolorframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_maskedcolorframe_get_data_byte_length(
        maskedcolorFrame: astra_maskedcolorframe_t,
        byteLength: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_maskedcolorframe_get_data_ptr(
        maskedcolorFrame: astra_maskedcolorframe_t,
        data: *mut *mut astra_rgba_pixel_t,
        byteLength: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_maskedcolorframe_copy_data(
        maskedcolorFrame: astra_maskedcolorframe_t,
        data: *mut astra_rgba_pixel_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_maskedcolorframe_get_metadata(
        maskedcolorFrame: astra_maskedcolorframe_t,
        metadata: *mut astra_image_metadata_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_maskedcolorframe_get_frameindex(
        maskedcolorFrame: astra_maskedcolorframe_t,
        index: *mut astra_frame_index_t,
    ) -> astra_status_t;
}
pub type astra_colorizedbodystream_t = astra_streamconnection_t;
pub type astra_colorizedbodyframe_t = *mut _astra_imageframe;
extern "C" {
    pub fn astra_reader_get_colorizedbodystream(
        reader: astra_reader_t,
        colorizedbodyStream: *mut astra_colorizedbodystream_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_colorizedbodystream_is_available(
        colorizedbodyStream: astra_colorizedbodystream_t,
        isAvailable: *mut bool,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_frame_get_colorizedbodyframe(
        readerFrame: astra_reader_frame_t,
        colorizedbodyFrame: *mut astra_colorizedbodyframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_frame_get_colorizedbodyframe_with_subtype(
        readerFrame: astra_reader_frame_t,
        subtype: astra_stream_subtype_t,
        colorizedbodyFrame: *mut astra_colorizedbodyframe_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_colorizedbodyframe_get_data_byte_length(
        colorizedbodyFrame: astra_colorizedbodyframe_t,
        byteLength: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_colorizedbodyframe_get_data_ptr(
        colorizedbodyFrame: astra_colorizedbodyframe_t,
        data: *mut *mut astra_rgba_pixel_t,
        byteLength: *mut u32,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_colorizedbodyframe_copy_data(
        colorizedbodyFrame: astra_colorizedbodyframe_t,
        data: *mut astra_rgba_pixel_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_colorizedbodyframe_get_metadata(
        colorizedbodyFrame: astra_colorizedbodyframe_t,
        metadata: *mut astra_image_metadata_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_colorizedbodyframe_get_frameindex(
        colorizedbodyFrame: astra_colorizedbodyframe_t,
        index: *mut astra_frame_index_t,
    ) -> astra_status_t;
}
extern "C" {
    pub fn astra_version(info: *mut astra_version_info_t) -> astra_status_t;
}
